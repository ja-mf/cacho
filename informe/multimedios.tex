\documentclass[a4paper,11pt]{article}
%\usepackage{ucs}
\usepackage{pstricks}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage{graphics}
\usepackage[margin=1in]{geometry}
\usepackage{fancyhdr}
%\usepackage{subfigure}
%\usepackage{wrapfig}
%\usepackage[amssymb,mediumspace]{SIunits}
\usepackage{listings}
%\usepackage{fullpage}


\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\pagestyle{fancy}
% Title Page
\setlength{\headwidth}{\textwidth}
\fancyhead[L]{TEL-332}% empty left
\fancyhead[R]{Multimedios}

%\renewcommand{\headheight}{0.6in}


% listings

\definecolor{Brown}{cmyk}{0,0.81,1,0.60}
\definecolor{OliveGreen}{cmyk}{0.64,0,0.95,0.40}
\definecolor{CadetBlue}{cmyk}{0.62,0.57,0.23,0}
\definecolor{lightlightgray}{gray}{0.9}

\lstset{
	language=Python,                             % Code langugage
	basicstyle=\ttfamily,                   % Code font, Examples: \footnotesize, \ttfamily
	keywordstyle=\color{OliveGreen},        % Keywords font ('*' = uppercase)
	commentstyle=\color{gray},              % Comments font
%	numbers=left,                           % Line nums position
%	numberstyle=\tiny,                      % Line-numbers fonts
	stepnumber=1,                           % Step between two line-numbers
	numbersep=5pt,                          % How far are line-numbers from code
	backgroundcolor=\color{lightlightgray}, % Choose background color
	frame=none,                             % A frame around the code
	tabsize=2,                              % Default tab size
	captionpos=b,                           % Caption-position = bottom
	breaklines=true,                        % Automatic line breaking?
	breakatwhitespace=false,                % Automatic breaks only at whitespace?
	showspaces=false,                       % Dont make spaces visible
	showtabs=false,                         % Dont make tabls visible
	columns=flexible,                       % Column format
	showstringspaces=false,
}


\title{Proyecto de multimedios\\Dudo!}
\author{Juan Mucarquer\\2830027-1\\\small{\texttt{<juan.mucarquer@alumnos.usm.cl>}} \and Sebastian Cáceres\\2830010-7\\\small{\texttt{<sebastian.caceresb@alumnos.usm.cl>}} \and Victor Fernandez\\2604041-8\\\small{\texttt{<victor.fernandez@alumnos.usm.cl>}}}
\begin{document}
%\begin{titlepage}
%	\input{portada}
%\end{titlepage}
\maketitle
%\renewcommand\thesubsection{\thesection\alph{subsection}}
%\setcounter{section}{1}

\newpage
\tableofcontents
\newpage

\section{Introducción}
\subsection{Trasfondo}
	En la actualidad, el desarrollo de aplicaciones web es muy popular. 
La mayoría de la gente tiene acceso a internet, y el mercado es muy prometedor.
Existen cientos (o miles) de aplicaciones con distintos fines, muchas muy 
buenas. Otras, quizás no tanto. \\

	Un subconjunto de estas aplicaciones son los juegos online. Estos 
juegos se han vuelto muy populares últimamente, probablemente debido a la
capacidad que poseen para manejar partidas multijugadores.\\

 Esto es muy atractivo, y existe una gran variedad de juegos que disponen 
de esta característica. Sin embargo, por lo general son solo típicos juegos 
de cartas.El enfoque que tomaremos será hacer algo distinto, implementar 
un juego de mesa que no sea de cartas, pero que tenga características 
similares a las descritas anteriormente. \\

El juego que implementaremos será el dudo.  
	

\subsection{Resumen}

	El proyecto total consta de 2 partes: el cliente, y el servidor. Una 
vez tengamos el cliente web, es posible que procedamos a implementarlo para 
dispositivos móviles. El objetivo que tendremos será hacer que la gente deje
de jugar típicos juegos de póker, y se cambie a jugar algo mas entretenido y
cercano como es el dudo.\\

	Otro aspecto importante es que dentro de los requerimientos de diseño
que nos hemos impuesto, esta el no utilizar Flash, y solo enfocarse en el 
correcto uso de Javascript y HTML5 para el proecto, acorde a las nuevas 
corrientes e ideologías de desarrollo de software. Por otra parte, nos 
enfocaremos en conexiones persistentes, y mensajería asincrónica entre el 
cliente y el servidor.

\newpage
\section{Descripción General}
\subsection{Objetivos}
\subsubsection{General}

	El objetivo principal de la aplicacion es ofrecer una plataforma para
un juego popular chileno, en linea, activo y rapido. La lógica del juego
es de relativa sencillez y las reglas son ampliamente conocidas, por lo que
pretende que el juego sea fácil e intuitivo para el usuario. Habrán varias
salas de juego, y el usuario podrá elegir a cual acceder para jugar su partida.


\subsubsection{Especificos}
\begin{itemize}
	\item Promover el juego del dudo.
	\item Disponer de un juego rapido e instantaneo
	\item Utilizar tecnologías que permitan su jugabilidad de forma nativa,
	no es necesario descargar nada para empezar a jugar.
	\item Contar con un chat y salas de juego.
	\item Establecer un protocolo de comunicación entre el cliente y el servidor (definición de mensajes).
\end{itemize}

\subsection{Problemática que enfrenta}

	La problemática que enfrenta el juego es, por un lado, el aburrimiento de las pobres personas. La gente necesita un juego bien codificado y funcional
que les brinde un alto nivel de entretención.\\

	Por otro lado, si bien existen bastantes juegos online en la actualidad,
creemos que no existe ninguno con el cual el usuario se pueda identificar,
debido a que ninguno de los que existe ahora es propiamente latinoamericano. 

\subsection{Descripción de la solución}
	
	La solución para ambas problemáticas es implementar el dudo 
multijugador online. Éste está dividido en dos partes: el cliente y el servidor.
\\

	En el lado del cliente, existirá un sistema de login, seguido de un 
menú de selección de salas, el cual mostrará las salas disponibles y los 
usuarios que estan en cada sala. El cliente entonces podrá elegir una sala 
para jugar su partida, la cual también contará con un chat en el cual 
participarán los jugadores que compartan una partida.\\

	El servidor se encargara de el paso de mensajes asincrónico, y de las
interacciones con la base de datos. Con esto, el servidor definirá la 
estructura del juego, y su secuencia. Esto se refiere a manejo de turnos, 
de interacciones "entre usuarios", de mensajes de chat, de usuarios dentro de 
la sala, de dados disponibles por usuario y su aleatorización, etc.
	

\subsection{Tecnologias utilizadas}
Para la parte del servidor, constará de una aplicacion MVC, utilizando el framework
Django (Python). Con el fin de tener una comunicación asincronica y activa entre
el cliente y el servidor, se utilizará un binding de la biblioteca Socket.IO (Javascript),
construido sobre gevent, una biblioteca basadas en co-rutinas para aplicaciones de red, llamado
gevent-socketio.\\

En el cliente se utilizará HTML5 y CSS para el diseño, y para la comunicación, Javascript
con la biblioteca Socket.IO, basada a su vez en node.js.\\

Se posee un repositorio git para el control de versiones, hospedado en github.com

\newpage
\section{Especificación de los requerimientos}
	
	Para especificar los requerimientos, primero es necesario establecer 
las reglas del juego.

\subsection{Reglas del juego}

	El juego parte cuando hay mas de dos jugadores listos para comenzar.
 Cada jugador parte con un total de 5 dados dentro de su \textit{cacho}. Las 
rondas del juego se realizan en sentido antihorario.\\

	Al comienzo de cada \textit{ronda}, los jugadores agitan los dados del 
cacho, es decir, reciben aleatoriamente los valores contenidos en sus dados.
Sólo ellos son capaces de ver el contenido de su cacho, no así los demás. \\

	En base a el contenido de su cacho, cada jugador especula el resultado 
de la suma de todos los dados cara arriba - con un determinado numero - 
obtenidos en total por todos los jugadores. Los ases, aparte de ser números
concretos, con comodines, y pueden obtener el valor del número que se esta 
contando.\\

	El jugador que parte \textit{canta} un numero estimado de dados. 
\textbf{(ej: "Hay tres quinas")}. \\

	El jugador siguiente tiene dos opciones: elevar el número especulado,
o dudar. \\

\begin{itemize}
\item Para elevar el número, existen tres maneras posibles. Una es aumentar la 
\textit{"pinta"} del dado (ej: De tres quinas a tres sextas). Otra es aumentar el numero de dados totales en la especulación (ej: De tres quinas a cuatro 
quinas). La última manera es una combinación de las dos maneras anteriores.
\item Si el jugador duda, todos los jugadores muestran los dados contenidos
en sus cachos, y estos se cuentan. Si la especulación era correcta, es decir,
hay sobre la mesa el número total de dados cantados por el primer jugador, el 
jugador que dudó pierde un dado. En el caso contrario, el jugador que cantó,
pierde un dado.
\end{itemize}

	El jugador que comienza cantando la siguiente ronda es el que pierde.\\

	Cuando a un jugador le queda un sólo dado, el jugador \textbf{obliga}.
En este caso, y sólo para esta ronda, sólo él puede ver el contenido de su 
cacho, nadie mas. Una vez que el jugador cante, nadie puede cambiar la pinta
cantada, y los ases dejan de ser comodines.\\

	El juego se termina cuando sólo queda un jugador con dados en su cacho,
y es él quien gana.\\

%\newpage

\subsection{Usuarios del sistema}

\begin{description}
	\item[Administrador] \hfill \\ \\
	El administrador es el encargado de crear y 
	regular los espacios y las características de la sala. Dentro de estos
	se incluyen la creación de salas, usuarios, etc.

	\item[Clientes] \hfill \\ \\
	Serán los principales usuarios del sistema. Los 
	clientes acceden al sistema, seleccionan salas, y juegan partidas.
\end{description}
\newpage	

\subsection{Descripción de los requerimientos}
\subsubsection{Funcionales}

\begin{description}
	\item[Requisito 1] \hfill \\ \\
	Implementar login y registro de usuarios.
	\item[Requisito 2] \hfill \\ \\
	Implementar login y panel de control de administrador.
	\item[Requisito 3] \hfill \\ \\
	Lista de salas de juego disponibles.
	\item[Requisito 4] \hfill \\ \\
	Lista de usuarios dentro de salas de juego.
	\item[Requisito 5] \hfill \\ \\
	Chat dentro de la sala de juego.
	\item[Requisito 6] \hfill \\ \\
	Botón confirmar inicio del juego, el cual es necesario que pulsen
	todos los jugadores dentro de una sala para comenzar la partida.
	\item[Requisito 7] \hfill \\ \\
	Implementación de lógica de juego del lado del servidor.
\end{description}
%\newpage

\subsubsection{No funcionales}

\begin{description}
	\item[Sencillez de uso] \hfill \\ \\
	El uso del sistema y de sus componentes debe ser intuitivo, lo mas 
	sencillo posible. Las opciones para el usuario deben estar acordes
	a estos principios. 
	\item[Fluidez] \hfill \\ \\
	Por otra parte, el juego debe funcionar lo mas fluidamente posible.
	Esto significa que toda la interacción del usuario, desde su login, 
	mientras dure la partida y su finalización, deben transcurrir dentro 
	de lo posible sin retardos ni cortes.
	\item[Escalabilidad] \hfill \\ \\
	El sistema debe ser modular en su construcción, permitiendo así 
	añadir futuras funcionalidades al juego que puedan mejorar su
	calidad. Es importante que se pueda hacer esto sin afectar la 
	codificación hecha anteriormente.

\end{description}
\newpage

\subsection{Tareas de usuario}

\begin{description}
	\item[Administrador] \hfill \\ \\
	La tarea del administrador es velar por el correcto orden esquemático
	del sitio. El estará encargado de crear salas, administrarlas o 
	borrarlas, dependiendo del caso. También tiene las mismas 
	responsabilidades con respecto a los usuarios. Al final de cuentas,
	es un usuario que interactúa directamente con la base de datos.

	\item[Clientes] \hfill \\ \\
	La tarea principal (y única) de los clientes será jugar partidas. Ellos
	ingresarán a el juego, logeandose. Luego buscarán una sala disponible.
	Al ingresar a una sala disponible, podrán salirse de ella, o confirmar
	su participación para el inicio del juego. Una vez terminada la partida,
	el usuario puede elegir entre jugar otra partida, o salirse del sistema.
	
\end{description}
\newpage
	

\subsection{Funciones del sistema}
Las funciones del sistema serán:\\

\textbf{Servidor:}
\begin{itemize}
	\item Manejar las sesiones de los usuarios, entrando
	mediante un formulario de login y permitir el registro de usuarios,
	usando un formulario de registro.
	\item Derivar las peticiones hechas por HTTP a la vista
	correspondiente (urls.py)
	\item Formatear la informacion para cada vista.
	\item Mostrar una lista de salas de juego con los usuarios
	dentro de cada sala y el estado de la sala (jugando o esperando).
	\item Derivar las conexiones y mensajes hechas mediante el 
	protocolo de Socket.IO hacia un modulo que se encargará de responder
	a estos mensajes (cacho\_socketio.py)
	\item Inicializar y responder a los mensajes enviados por los clientes,
	según un protocolo de juego, descrito posteriormente en el 
	diagrama de secuencia.
	\item Mantener e interactuar con el modelo de datos para las
	operaciones que lo requieran.
\end{itemize}
\vspace{0.7cm}
\textbf{Cliente:}
\begin{itemize}
	\item Registrarse con un nombre de usuario y contraseña
	\item Unirse a una sala de juego que actualmente esté esperando
	jugadores.
	\item Enviar un mensaje a una sala de juego
	\item Confirmar el inicio del juego por parte de un usuario.
	\item Recibir y mostrar los dados para el jugador
	\item Enviar una jugada, un dudo o calzo.
\end{itemize}
\newpage

\section{Diseño de la interfaz de usuario}
\subsection{Esquema navegacional}
\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{Esquema_navegacional.png}
\end{figure}
\newpage

\subsection{Prototipos de pantalla}
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\textwidth]{Login.png}
	\caption{Login}
\end{figure}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\textwidth]{Sign_in.png}
	\caption{Sign in}
\end{figure}
\newpage
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\textwidth]{Sala.png}
	\caption{Sala de juego}
\end{figure}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\textwidth]{salas.png}
	\caption{Lista de salas de juego}
\end{figure}
\newpage
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.9\textwidth]{Admin_log.png}
	\caption{Log in del panel de administración}
\end{figure}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.9\textwidth]{AdminCp.png}
	\caption{Vista principal del panel de administración}
\end{figure}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.9\textwidth]{Admin_addroom.png}
	\caption{Agregar nueva sala}
\end{figure}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.9\textwidth]{Admin_adduser.png}
	\caption{Agregar nuevo usuario}
\end{figure}

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.9\textwidth]{Admin_room_cp.png}
	\caption{Editar sala}
\end{figure}
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.9\textwidth]{Admin_user_cp.png}
	\caption{Editar usuario}
\end{figure}

\newpage

\section{Diseño del sistema}
\subsection{Diseño de la arquitectura}
	El diseño de arquitecturas que utilizaremos será el modelo MVC. 
Este se divide en 3 partes:
\begin{itemize}
	\item \textbf{Modelo:} El modelo es una entidad que representa la 
información específica con la cual el sistema opera (La base de datos). 
Interactúa con la \textbf{Vista} y el \textbf{Controlador} cuando hay un cambio
de su estado. Esta interacción permite a la vista entregar contenido actualizado, 
y a el controlador a cambiar el set de comandos disponibles. \\
	\item \textbf{Controlador:} El controlador maneja el modelo, 
interactúa con él y lo modifica, en respuesta a  eventos generados por el 
usuario. El controlador también puede interactuar con las vistas, 
actualizandolas. \\
	\item \textbf{Vista:} La vista interactúa con el modelo, pidiendole la
información que necesita para representar los datos para el usuario. \\
\end{itemize}

Elegimos esta arquitectura porque resulta natural trabajar con ella 
para el tipo de proyecto que estamos desarrollando. La mayoría del 
funcionamiento del sistema esta basado en eventos que van a gatillar 
interacciones con el modelo, y estas modificaciones del mismo producirán 
cambios en la vista, ocurriendo todo esto asincrónicamente.
\newpage
\subsection{Diseño lógico}
%\subsubsection{Diagrama de clases}
\subsubsection{Diagrama de casos de uso}
	El diagrama de casos de uso presenta a los dos actores presentes en
el juego: el cliente y el administrador. En el se especifican las funciones e
interacciones que tienen cada uno de ellos con el sistema.
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.9\textwidth]{diag_casos_uso.png}
\end{figure}

\subsubsection{Modelo de datos}
Se definieron dos modelos de datos GameRoom y GameUser. User lo provee Django.
\begin{figure}[h!]
	\centering
	\includegraphics[width=\textwidth]{md.png}
\end{figure}

\newpage
\subsubsection{Diagrama de secuencia}
El siguiente diagrama de secuencia muestra el protocolo de intercambio de mensajes
entre el cliente y el servidor para un juego. Mas adelante se explicará el contexto
y el significado de cada mensaje.
\begin{figure}[h!]
	\centering
	\includegraphics[width=\textwidth]{seq_juego.png}
\end{figure}
\newpage
\section{Implementación}
\subsection{Descripción de componentes}
Actualmente, el servidor consta de un proyecto de Django, el cual tiene dos aplicaciones,
\texttt{cacho\_site} y \texttt{cacho\_app}.\\

\texttt{cacho\_site} pretende tener objetos y sistemas
relacionados con el sitio entero, se compone de los siguientes modulos:\\

\textbf{urls.py:} Derivará una URL hacia una vista o modulo.
En el caso de \texttt{/socket.io}, lo derivará al Namespace especifico
al cual se quiere conectar. Al ingresar a \texttt{/play/} se cargarán las URL
de la aplicación \texttt{cacho\_app}.
\begin{lstlisting}[language=Python, caption=cacho\_site/urls.py]
urlpatterns = patterns('',
	url(r'^admin/', include(admin.site.urls)),
	url(r'^login/$', 'django.contrib.auth.views.login'),
	url(r'^play/', include("cacho_app.urls")),

	# socket.io
   url("^socket\.io", include(socketio.sdjango.urls)),
)

urlpatterns += patterns('cacho_site.views', 
	# login logout
	url(r'^logout/', 'logout_view'),
\end{lstlisting}
\vspace{1cm}
\textbf{views.py}: Renderizará un template para el index y hará el logout.
El objeto \texttt{request.user} mantiene las variables de sesion del usuario logueado.
\texttt{@login\_required} es un decorador de la aplicación de autenticacion que provee
Django (\texttt{django.contrib.auth}), un filtro para usar el metodo que le sigue.
\begin{lstlisting}[language=Python, caption=cacho\_site/views.py]
@login_required
def index(request):
	return HttpResponse('this is index. welcome ' + request.user.get_full_name())

def logout_view(request):
	logout(request)
	HttpResponse("Logged out!")
	return HttpResponseRedirect('/login/')
\end{lstlisting}

\newpage
\subsection{Aplicación del juego}
\texttt{cacho\_app} pretende mantener objetos y modulos relacionados solo
con la aplicacion de juego, usando las sesiones y modelos de \texttt{cacho\_site}.\\

Se compone de los siguientes modulos:\\

\textbf{urls.py}: Cuando se ingresa a \texttt{/} (\texttt{/play/}) se mostrará
la lista de las salas, mientras que por un nombre, se ingresará a la sala con el
\texttt{slug} de la URL.
\begin{lstlisting}[caption=cacho\_app/urls.py]
urlpatterns = patterns("cacho_app.views",
	url("^$", "rooms", name="rooms"),
	url("^(?P<slug>.*)$", "room", name="room"),
)
\end{lstlisting}
\vspace{1cm}
\textbf{views.py}: Dos vistas, una para listar todos los rooms, haciendo
referencia al modelo (GameRoom) y luego renderizando la vista mediante el template
\texttt{rooms.html}. \texttt{room} buscará el slug en el modelo y lo enviará al template
para renderizarlo. Si no encuentra el slug arrojará un error 404.
\begin{lstlisting}[caption=cacho\_app/views.py]
@login_required
def rooms(request, template="rooms.html"):
    """
    Listar todos los rooms y sus participantes
    """
    context = {"rooms": GameRoom.objects.all()}
    return render(request, template, context)

@login_required
def room(request, slug, template="room.html"):
    """
    Entrar a una sala de juego
    """
    logged_user = request.user.get_full_name()
    context = {"room": get_object_or_404(GameRoom, slug=slug), "user": logged_user}
    return render(request, template, context)
\end{lstlisting}
\newpage
\textbf{Dudo.py}: Contiene funciones utilitarias para la logica del juego.
RingBuffer es usado para el manejo de turnos, es una lista circular, la cual a traves
del metodo \texttt{get()} se obtiene el proximo elemento de la lista.\\

Dudo es una clase que implementa un solo metodo hasta el momento, \texttt{posibles(mov, max\_dados)}, donde \texttt{mov} es una 2-tupla que indicará un movimiento. Este metodo devolverá
los movimientos (2-tuplas) que son posibles de realizar (y que van con las reglas del dudo), segun una cantidad de dados. Así, cuando al jugador le llegue el turno, se le enviará una lista de movimientos posibles en base al movimiento efectuado por el jugador anterior. Con esta lista se pretende poblar un formulario en el cliente que tiene el turno, limitando sus jugadas a jugadas que sean posibles y tengan sentido.
\begin{lstlisting}[caption=Dudo.py]
class RingBuffer:
	def __init__(self):
		self.data = []
		self.cur=0
	def append(self,x):
		"""append an element at the end of the buffer"""
		self.data.append(x)
	def get(self):
		self.cur+=1
		if len(self.data) == self.cur:
			self.cur=0 	
		return self.data[self.cur]

class Dudo:
	def posibles(self, movimiento, maximo_dados):
		movimientos_posibles = []
		pinta = 0
		if movimiento[1] != 1:
			for i in range (movimiento[0], maximo_dados+1):
				if pinta == 0:
					movimientos_posibles.append(((movimiento[0]/2)+1,1))
					for j in range (movimiento[1]+1, 7):
						movimientos_posibles.append((i,j))
					pinta = 1
				else:
					for j in range (1,7):
						movimientos_posibles.append((i,j))
		else:
			for i in range (movimiento[0]+1, maximo_dados+1):
				movimientos_posibles.append((i,1))
			for i in range (movimiento[0]*2, maximo_dados+1):
				for j in range (2, 7):
					movimientos_posibles.append((i,j))
		return movimientos_posibles
\end{lstlisting}

\newpage
\textbf{cacho\_socketio.py}: A este modulo llegarán las conexiones y mensajes que 
provienen del cliente Javascript. Según el protocolo de Socket.IO, el cliente 
se debe conectar a un Namespace, un espacio de nombres especifico que mantiene 
un conjunto de funciones. En este caso, se definió el namespace 
\texttt{/game}, el cual agrupa funciones referentes al juego. \\

Cada petición \texttt{HTTP GET} será una instancia de esta clase (GameNamespace), por lo tanto
manejará la interacción con un solo cliente logeado. Cada una de estas funciones se ejecutará
dependiendo del mensaje que envíe el cliente. El objeto \texttt{request} al cual se tenía
acceso en \texttt{views.py} es duplicado, y accesible desde aqui como \texttt{self.request},
pudiendo manejar variables de sesión del sitio en el ambiente que interactua con el cliente Javascript.\\

Un mensaje/evento se compone de un nombre y sus datos, los cuales serán serializados a JSON
para su posterior entendimiento en el cliente Javascript. Un metodo del Namespace es el nombre de un evento, precedido por \textbf{on\_}. e.g: el mensaje enviado desde 
el cliente \texttt{('join', room)}, gatillará el evento \texttt{on\_join(self, room\_in)}, donde el argumento será su dato. Este dato como se dijo, puede ser cualquier objeto notado en JSON.\\

Este Namespace hereda metodos y variables que son utiles para la comunicacion: 
\texttt{emit()}, \texttt{emit\_to\_room()}, \texttt{socket.sessid}, por ejemplo. Para una completa lista revisar la API de referencia \footnote{\texttt{https://gevent-socketio.readthedocs.org/en/latest/namespace.html}}

\begin{lstlisting}[caption=cacho\_app/cacho\_socketio.py]
from socketio.namespace import BaseNamespace
from socketio.mixins import RoomsMixin, BroadcastMixin
from socketio.sdjango import namespace

@namespace('/game')
class GameNamespace(BaseNamespace, RoomsMixin, BroadcastMixin):
	def initialize(self):
		pass

	def on_join(self, room_in):
		pass

	def on_confirmar(self, action):
		pass
	
	def on_get_dados(self):
		pass

	def on_get_jugadas_posibles(self):
		pass

	def on_jugada(self, jugada):
		pass

\end{lstlisting}
\newpage
\subsubsection{Modelo de datos}
El modelo de datos se definió en models.py como sigue. La funcion \texttt{slugify} convierte un nombre
que puede contener espacios y otros caracteres en un string que puede ser concatenado a una URL, ese será
el metodo de acceso a una sala.\\

La tabla \texttt{GameUser} mantendrá los usuarios que estan actualmente en las salas de juego,
donde session pertenece al \texttt{session\_id} de la sesión iniciada por Socket.IO.

\begin{lstlisting}[caption=cacho\_app/models.py]
class GameRoom(models.Model):

    name = models.CharField(max_length=20)
    slug = models.SlugField(blank=True)
    state = models.BooleanField(default=False) 

    class Meta:
        ordering = ("name",)

    def __unicode__(self):
        return self.name

    @models.permalink
    def get_absolute_url(self):
        return ("room", (self.slug,))

    def save(self, *args, **kwargs):
        if not self.slug:
            self.slug = slugify(self.name)
        super(GameRoom, self).save(*args, **kwargs)

class GameUser(models.Model):

   user = models.ForeignKey(User)
   session = models.CharField(max_length=20)
   room = models.ForeignKey("cacho_app.GameRoom", related_name="users")
   confirm = models.BooleanField(default=False)

	class Meta:
       ordering = ("room",)
   
   def __unicode__(self):
       return self.user.username

\end{lstlisting}

\newpage

\section{Conclusiones}

	Al final de esta etapa de desarrollo, hemos concluido que:

\begin{itemize}
	\item Las funcionalidades del servidor estan completas casi a cabalidad.
	Faltará adaptarlas un poco al momento de desarrollar el cliente, y
	quizás agregar alguna modificación o funcionalidad.
	\item Es posible que cambiemos el tipo de interacción con la base de
	datos, para disminuir el número de consultas totales realizadas.
	Esto se verá en el camino, pero existe una gran posibilidad.
	\item El modelo MVC es muy útil y eficiente a la hora de realizar
	aplicaciones con paso de mensajes asincrónicos, ya que para efectos
	de visualización por parte del cliente, las vistas se actualizan 
	al haber un cambio en el modelo. Resulta muy natural.

\end{itemize}

\section{Referencias}
\begin{enumerate}
	\item Documentación oficial de Django -- https://docs.djangoproject.com/en/1.4/
	\item Documentacion de Python -- http://docs.python.org
	\item gevent-socketio API docs. -- https://gevent-socketio.readthedocs.org/
	\item Socket.IO recipes -- https://github.com/LearnBoost/socket.io
	\item Developing Django apps with zc.buildout -- http://jacobian.org/writing/django-apps-with-buildout/
	\item Evented Django -- http://codysoyland.com/2011/feb/6/evented-django-part-one-socketio-and-gevent/
	\item IRC, \#django y \#python en irc.freenode.net
\end{enumerate}

\end{document}


